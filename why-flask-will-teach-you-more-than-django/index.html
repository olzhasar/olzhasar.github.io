<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>Why Flask will teach you more about software engineering than Django</title>
    <meta name="description" content="Personal blog">

    <link rel="stylesheet" href="https://olzhasar.github.io/main.css">

    

    
    
</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;olzhasar.github.io&#x2F;">Olzhas Arystanov</a>
            </h1>
            <nav>
                
                
                
                <a  href="https:&#x2F;&#x2F;github.com&#x2F;olzhasar&#x2F;">Github</a>
                
                
                <a  href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;olzhas-arystanov&#x2F;">LinkedIn</a>
                
                
            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>Why Flask will teach you more about software engineering than Django</h1>
    </header>
    <div class="content">
        <h2 id="intro">Intro<a class="zola-anchor" href="#intro" aria-label="Anchor link for: intro">ðŸ”—</a></h2>
<p>I started my journey in web development with Django. That was the first framework that Iâ€™ve learned right after familiarizing myself with a bit of Python programming language. Pretty soon I was able to write a couple of web applications with it. I was so fascinated by the fact that I can build a full-featured website in a couple of days or sometimes hours depending on project complexity. I remember trying Flask for a couple of pet projects. Sometimes I managed to build something simple with it but as complexity started to grow, I would give up sooner or later. Django was so much easier to work with for me as a beginning software engineer. When I was stuck with something in Django, almost every time there will be a detailed answer on stackoverflow. It wasn't that easy to find with Flask. As a result, I played with Flask here and there but never built anything serious with it.</p>
<h2 id="second-try">Second try<a class="zola-anchor" href="#second-try" aria-label="Anchor link for: second-try">ðŸ”—</a></h2>
<p>After several years of working with Django both at my job and for personal projects, I finally decided to give Flask another try and dive deep into it. The main motivation for me this time was my desire to learn SQLAlchemy ORM. I was already a middle engineer at that point, knowing something about servers, databases and software design. I started a toy project and surprisingly managed to finish it in a couple of days. Moreover, I totally fell in love with the process of building it. Flask gave me complete freedom over the application design and I utilized that opportunity to create an app that would perfectly suit my every need. I used Flask for almost every personal project since then and I learned a lot while doing them. I thought about my experience with Django and I finally came to a conclusion that choosing Flask at the very beginning of my career would be a much more beneficial decision in the long run.</p>
<p>Let's walk over some points where I think Flask compared to Django can be more enlightening especially to entry-level engineers.</p>
<h2 id="implementing-things-from-scratch">Implementing things from scratch<a class="zola-anchor" href="#implementing-things-from-scratch" aria-label="Anchor link for: implementing-things-from-scratch">ðŸ”—</a></h2>
<p>Django comes batteries-included. It has features for almost any use case that an average web project will ever come up with. You can build a working authentication system in Django in no time and knowing nothing about things that are going on under the hood. Django will take care of hashing passwords, storing them in database, verifying them later when a user tries to sign in, managing user sessions, and a lot more.</p>
<p>Flask in comparison is extremely lightweight out of the box. It does not give you much. You are on your own. You can utilize some third-party library to solve some common tasks, or you can build things from scratch. If you choose the latter option, this is where the actual learning lies. You will spend much more time thinking about what your code is actually doing by starting from zero.</p>
<h2 id="design-philosophy">Design philosophy<a class="zola-anchor" href="#design-philosophy" aria-label="Anchor link for: design-philosophy">ðŸ”—</a></h2>
<p>Django is an absolutely beautiful piece of software. There are so many brilliant design decisions in Django's codebase that made working with the framework a piece of cake. But there is a downside to that beauty when it comes to learning things because almost all design decisions are already made for you. Django expects almost everything to be done Django-way. You obviously can ditch all the built-in abstractions and write your own from scratch, but this will likely make your project significantly deviate from Django's philosophy. With a complex long-term project, you can come to a point when there are no reasons left to use Django at all.</p>
<p>Flask, contrastingly, does not force you to do things a certain way. Once again, you have a complete freedom, and you can do pretty much anything you want. That also means that you will probably make bad decisions in the beginning of your journey, but that's where you will learn a lot. If you ever played chess, you probably started as a pretty bad player. But the more bad moves you make and games you lose, the more you analyze your mistakes and correct your strategy, which results in your progress. I believe the same principle applies to software engineering. Nobody learned to produce perfect computer programs right from the start. You absolutely need to make a lot of mistakes and analyze outcomes to truly master your software design skills. And Flask is the perfect tool to make such mistakes and progress as a software engineer.</p>
<h2 id="sqlalchemy-vs-django-orm">SQLAlchemy vs Django ORM<a class="zola-anchor" href="#sqlalchemy-vs-django-orm" aria-label="Anchor link for: sqlalchemy-vs-django-orm">ðŸ”—</a></h2>
<p>Even though Flask is not coupled with any ORM solution out of the box, developers typically choose <a href="https://www.sqlalchemy.org/">SQLAlchemy</a> to work with relational databases in their Flask applications. Django comes with its own Object-relational mapping tool which is oftentimes called Django ORM. These two ORM solutions follow quite different data access patterns: SQLAlchemy uses <a href="https://en.wikipedia.org/wiki/Data_mapper_pattern">Data mapper pattern</a> and Django ORM uses <a href="https://en.wikipedia.org/wiki/Active_record_pattern">Active Record Pattern</a>. What it means is that Django maps every python object to a particular row in a database whereas in SQLAlchemy database operations and python objects are separated. Consider the following example of querying and deleting a row in a database:</p>
<p>Django:</p>
<pre data-lang="py3" style="background-color:#2b303b;color:#c0c5ce;" class="language-py3 "><code class="language-py3" data-lang="py3"><span>user = User.objects.</span><span style="color:#bf616a;">get</span><span>(</span><span style="color:#bf616a;">id</span><span>=</span><span style="color:#d08770;">1</span><span>)
</span><span>user.</span><span style="color:#bf616a;">delete</span><span>()
</span></code></pre>
<p>SQLAlchemy:</p>
<pre data-lang="py3" style="background-color:#2b303b;color:#c0c5ce;" class="language-py3 "><code class="language-py3" data-lang="py3"><span>user = session.</span><span style="color:#bf616a;">query</span><span>(User).</span><span style="color:#bf616a;">get</span><span>(</span><span style="color:#d08770;">1</span><span>)
</span><span>session.</span><span style="color:#bf616a;">delete</span><span>(user)
</span><span>session.</span><span style="color:#bf616a;">commit</span><span>()
</span></code></pre>
<p>Django allows you to call obj.delete() method directly on the model instance because that instance is mapped to a specific row in the database. SQLAlchemy expects you to use session for making final queries. The latter approach can actually be safer in many situations because you always instruct the database explicitly whether to perform a particular query or not. To illustrate this point, consider the following example in Django:</p>
<pre data-lang="py3" style="background-color:#2b303b;color:#c0c5ce;" class="language-py3 "><code class="language-py3" data-lang="py3"><span>users = user.objects.</span><span style="color:#bf616a;">all</span><span>()
</span><span style="color:#b48ead;">for </span><span>user </span><span style="color:#b48ead;">in </span><span>users:
</span><span>    user.name
</span></code></pre>
<p>In Django ORM, queries are lazy by default which means their execution is postponed to the last moment when you will actually do something with the data. In this example, the query will be performed only on the second line of code when the iteration starts. Now let's say you have the following code:</p>
<pre data-lang="py3" style="background-color:#2b303b;color:#c0c5ce;" class="language-py3 "><code class="language-py3" data-lang="py3"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">some_func</span><span>(</span><span style="color:#bf616a;">users</span><span>):
</span><span>    </span><span style="color:#b48ead;">for </span><span>user </span><span style="color:#b48ead;">in </span><span>users:
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(user.name)
</span></code></pre>
<p>We cannot say for sure when the query will actually be performed because we don't know was this queryset of users evaluated earlier or not. This can lead to undesired side effects especially during development of large software projects.</p>
<p>I've worked with both ORMs in a bunch of projects and my personal opinion is that SQLAlchemy is safer and also makes you think more in terms of actual SQL queries that the database will produce compared to Django. Forming that mindset in my opinion is extremely beneficial for any entry-level backend engineer.</p>
<h2 id="summary">Summary<a class="zola-anchor" href="#summary" aria-label="Anchor link for: summary">ðŸ”—</a></h2>
<p>In conclusion, Django is undoubtedly a great web framework that will make your life easier especially if you have tight deadlines and want to iterate as quickly as possible. But it comes with a lot of magic hidden inside that prevents developers from understanding the whole picture. If you are not yet a highly experienced engineer and lack some knowledge, I would strongly recommend you to try Flask at least for your side projects. It will probably take more of your working time if you are justing starting out with Flask, but that will be an important investment in your backend development skills. On the other hand, if you are an experienced engineer but want to drop the boundaries and implement your brilliant design decisions in a complete freedom, you will also profit a lot by choosing Flask as your framework.</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date">11 September 2021</div>
        
        <div class="article-taxonomies">
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://olzhasar.github.io/tags/flask/">#flask</a></li>
                    
                    <li><a href="https://olzhasar.github.io/tags/django/">#django</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                Â© Olzhas Arystanov 2023<br>
                Powered by <a target="_blank" href="https://getzola.org/">Zola</a>, Theme <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>
</html>
