<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>A better way to prepare for your tech interviews</title>
    <meta name="description" content="Personal blog">

    <link rel="stylesheet" href="https://olzhasar.github.io/main.css">

    

    
    
</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;olzhasar.github.io&#x2F;">Olzhas Arystanov</a>
            </h1>
            <nav>
                
                
                
                <a  href="https:&#x2F;&#x2F;github.com&#x2F;olzhasar&#x2F;">Github</a>
                
                
                <a  href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;olzhas-arystanov&#x2F;">LinkedIn</a>
                
                
            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>A better way to prepare for your tech interviews</h1>
    </header>
    <div class="content">
        <p>I recently started applying to Big Tech companies, and as a result, I ended up solving a lot of LeetCode problems (284 problems at the time of writing this blog post). During the preparation process, it became clear to me why so many developers argue about the broken state of the tech interviewing process. Solving LeetCode problems takes a significant amount of time and energy that could otherwise be spent on building projects. However, I believe that the main issue lies not with the tech interviews themselves, but rather with the preparation process.</p>
<p>You have probably already chosen a list of LeetCode problems that you need to solve. If you haven't, fortunately, there are very good lists available online, such as the <a href="https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions">Blind 75</a> or <a href="https://neetcode.io/practice">Neetcode 150</a>. Each list usually covers multiple topics, including arrays, string manipulation, hashmaps, backtracking, dynamic programming, graph algorithms, etc. So, you start solving these problems one by one. If you have a good understanding of each of these topics, solving LeetCode problems becomes almost a mechanical process of sharpening your skills, becoming faster, and getting more accustomed to the coding interview process in general. However, if you lack a solid understanding of any of these areas, that's where the problem arises.</p>
<p>Let's say you struggle with backtracking algorithms. You have never implemented one before, and you are not sure how they work in general. In that case, there are multiple strategies you can follow:</p>
<ul>
<li>Spend hours trying to solve the problem by yourself.</li>
<li>Look up the solution on LeetCode.</li>
<li>Find a step-by-step guide on solving the problem (e.g., the <a href="https://www.youtube.com/c/neetcode">Neetcode YouTube channel</a>).</li>
</ul>
<p>The first approach is not ideal, especially if you have an ego like myself (I'm working on it). You can spend a lot of hours trying hard, but if you are not familiar with the concepts, those hours will likely be wasted. The second and third approaches are much better. You read or watch the solution, understanding the thought process behind it, and then (hopefully) try to replicate it yourself. However, the problem with this approach is that it's still just a single problem out of the 75 or 150 (or however many problems you plan to solve), and you treat it as such. In my experience, this approach does not allow you to fully understand the concept and build a long-term memory of it.</p>
<p>So, what can we do better to fully grasp the concept? I am a strong advocate of the &quot;learning-by-doing&quot; technique, and I suggest utilizing it here. The idea is to build a small or medium-sized project in your programming language of choice where a certain concept is applied. For example, if we are talking about backtracking algorithms, you can build a fully functional Sudoku game.</p>
<p>Why is this approach better?</p>
<ul>
<li>You can see how the concept you are exploring can be applied to solve a real problem.</li>
<li>Spending a significant amount of time on a single LeetCode problem can be really tedious. In contrast, building a project should give you much more motivation to stay focused. And it's completely okay to spend multiple days or weeks working on it.</li>
<li>You are much more likely to return to your project later to polish things than returning to your solved LeetCode problems.</li>
<li>It should be enough to build a single project for each topic to gain an understanding. After that, you can return to solving LeetCode problems in that topic, and it should be much easier and more fun now.</li>
</ul>

    </div>

    
    <div class="article-info">
        
        <div class="article-date">19 May 2023</div>
        
        <div class="article-taxonomies">
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://olzhasar.github.io/tags/tech-interview/">#tech-interview</a></li>
                    
                    <li><a href="https://olzhasar.github.io/tags/leetcode/">#leetcode</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                Â© Olzhas Arystanov 2023<br>
                Powered by <a target="_blank" href="https://getzola.org/">Zola</a>, Theme <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>
</html>
