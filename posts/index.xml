<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on</title><link>/posts/</link><description>Recent content in Posts on</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 01 Sep 2024 21:32:41 +0500</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Prioritizing Tasks With Celery and Redis</title><link>/posts/prioritizing-tasks-with-celery-and-redis/</link><pubDate>Sun, 01 Sep 2024 21:32:41 +0500</pubDate><guid>/posts/prioritizing-tasks-with-celery-and-redis/</guid><description>&lt;p>Task prioritization can be an effective technique to ensure the most critical tasks are processed in time. There are other ways to achieve this, like using dedicated workers, but prioritizing is arguably the simplest, and in many cases, the most cost-effective approach. Celery supports task prioritization natively, but it works differently depending on the broker you use. If you use RabbitMQ, for example, prioritizing will be handled on the broker side, meaning that the broker will decide which message to deliver first. However, RabbitMQ might be an overkill for a lot of projects, and Redis is often preferred due to its simplicity. It turns out, one can still prioritize tasks with Redis, but it works in a slightly different fashion.&lt;/p></description></item><item><title>Use autospeccing for your mocks in Python</title><link>/posts/use-autospeccing-for-your-mocks-in-python/</link><pubDate>Mon, 05 Feb 2024 00:00:00 +0000</pubDate><guid>/posts/use-autospeccing-for-your-mocks-in-python/</guid><description>&lt;p>Mocks are a powerful concept in testing. They are one of several types of &lt;a href="https://martinfowler.com/bliki/TestDouble.html">test doubles&lt;/a>, which are objects that can be used in place of real objects in your tests. Mocks are used to isolate the code under test from the rest of the system, and to verify that the code under test interacts with its dependencies correctly. However, if not used properly, mocks can lead to false positives in your tests. One common pitfall is that mocks can be too permissive, allowing you to call methods that don&amp;rsquo;t exist on the real object. This can lead to tests that pass even when the code under test is broken.&lt;/p></description></item><item><title>The truth about becoming a self-taught software engineer</title><link>/posts/the-truth-about-becoming-a-self-taught-software-engineer/</link><pubDate>Wed, 05 Jul 2023 12:17:58 +0600</pubDate><guid>/posts/the-truth-about-becoming-a-self-taught-software-engineer/</guid><description>&lt;p>I graduated from a university with a degree in Finance and immediately started my career in investment banking. After about 7 years of working in the industry, the realization came to me that it wasn&amp;rsquo;t for me. So in my late 20s I decided to change my career path completely and become a software engineer. I did not have much time nor motivation to obtain another college degree, so I decided to take self learning path. And the transitioning process was much harder than I could imagine, it was probably the hardest thing I&amp;rsquo;ve ever done in my life.&lt;/p></description></item><item><title>Supercharge Your Python TDD Workflow With pytest-watcher</title><link>/posts/supercharge-your-python-tdd-workflow-with-pytest-watcher/</link><pubDate>Thu, 08 Jun 2023 05:37:36 +0600</pubDate><guid>/posts/supercharge-your-python-tdd-workflow-with-pytest-watcher/</guid><description>&lt;p>If you follow the &lt;a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-driven Development&lt;/a> practice in your Python projects, you need to run your test suite &lt;strong>often&lt;/strong>. Having to run it manually can become tedious. You can configure handy shortcuts in your favorite IDE to make the process easier. But there is even better way using &lt;a href="https://pypi.org/project/pytest-watcher/">&lt;code>pytest-watcher&lt;/code>&lt;/a>.&lt;/p>
&lt;h2 id="what-is-pytest-watcher">What is &lt;code>pytest-watcher&lt;/code>?&lt;/h2>
&lt;p>&lt;code>pytest-watcher&lt;/code> is a continuous test runner for Python projects that reruns your tests whenever you change a &lt;code>*.py&lt;/code> file inside your project.&lt;/p></description></item><item><title>Unlocking the power of asyncio Semaphore</title><link>/posts/unlocking-the-power-of-asyncio-semaphore/</link><pubDate>Wed, 31 May 2023 10:10:15 +0600</pubDate><guid>/posts/unlocking-the-power-of-asyncio-semaphore/</guid><description>&lt;p>When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.&lt;/p>
&lt;p>&lt;code>asyncio&lt;/code> library provides a dedicated synchronization primitive &lt;a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore">&lt;code>Semaphore&lt;/code>&lt;/a> created exactly for this purpose. However, let&amp;rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.&lt;/p>
&lt;p>We can limit the number of simultaneous connections by using a &lt;code>counter&lt;/code> variable that will be incremented whenever we start making a request and decremented when we receive our response. Let&amp;rsquo;s look at the example code:&lt;/p></description></item><item><title>Advent of Code vs LeetCode</title><link>/posts/advent-of-code-vs-leetcode/</link><pubDate>Sat, 20 May 2023 00:00:00 +0000</pubDate><guid>/posts/advent-of-code-vs-leetcode/</guid><description>&lt;p>I recently discovered the &lt;a href="https://adventofcode.com/">Advent of Code&lt;/a> project for myself and I absolutely loved it. At first glance, it seemed similar to solving &lt;code>Leetcode&lt;/code> problems. However, after trying it for a few days now I realized that I like the experience much more. In this short blog post I&amp;rsquo;ll try to break down main advantages that I see over &lt;code>Leetcode&lt;/code>:&lt;/p>
&lt;h3 id="no-online-editor">No online editor&lt;/h3>
&lt;p>You don&amp;rsquo;t have to use the poor built-in online editor. I can freely use my favorite &lt;code>Neovim&lt;/code> for this&lt;/p></description></item><item><title>A better way to prepare for your coding interviews</title><link>/posts/a-better-way-to-prepare-for-your-coding-interviews/</link><pubDate>Fri, 19 May 2023 00:00:00 +0000</pubDate><guid>/posts/a-better-way-to-prepare-for-your-coding-interviews/</guid><description>&lt;p>I recently started applying to Big Tech companies, and as a result, I ended up solving a lot of LeetCode problems (284 problems at the time of writing this blog post). During the preparation process, it became clear to me why so many developers argue about the broken state of the tech interviewing process. Solving LeetCode problems takes a significant amount of time and energy that could otherwise be spent on building projects. However, I believe that the main issue lies not with the tech interviews themselves, but rather with the preparation process.&lt;/p></description></item><item><title>Optimizing your Django tests</title><link>/posts/optimizing-your-django-tests/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/optimizing-your-django-tests/</guid><description>&lt;p>If you are working on a large Django project, you probably have lots of automated tests running as part of your CI/CD process. As long as tests run fast, everyone is happy. But as your application grows in complexity, your tests start to take more and more time to run and eventually become a real bottleneck. In this post, I will share some ideas that can help you optimize runtime of your test suite. I assume you are using &lt;strong>&lt;code>pytest&lt;/code>&lt;/strong>, but recommendations described in this post should be easily applicable to other runners as well.&lt;/p></description></item></channel></rss>