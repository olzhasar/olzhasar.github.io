<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unlocking the power of asyncio Semaphore | Olzhas Arystanov</title>
<meta name=keywords content="asyncio,python"><meta name=description content="When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.
asyncio library provides a dedicated synchronization primitive Semaphore created exactly for this purpose. However, let&rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.
We can limit the number of simultaneous connections by using a counter variable that will be incremented whenever we start making a request and decremented when we receive our response. Let&rsquo;s look at the example code:"><meta name=author content><link rel=canonical href=https://olzhasar.com/posts/unlocking-the-power-of-asyncio-semaphore/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://olzhasar.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://olzhasar.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://olzhasar.com/favicon-32x32.png><link rel=apple-touch-icon href=https://olzhasar.com/apple-touch-icon.png><link rel=mask-icon href=https://olzhasar.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://olzhasar.com/posts/unlocking-the-power-of-asyncio-semaphore/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.counter.dev/script.js data-id=3dd77a42-dfdd-4a54-b59c-cfff02697a3f data-utcoffset=6></script><meta property="og:title" content="Unlocking the power of asyncio Semaphore"><meta property="og:description" content="When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.
asyncio library provides a dedicated synchronization primitive Semaphore created exactly for this purpose. However, let&rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.
We can limit the number of simultaneous connections by using a counter variable that will be incremented whenever we start making a request and decremented when we receive our response. Let&rsquo;s look at the example code:"><meta property="og:type" content="article"><meta property="og:url" content="https://olzhasar.com/posts/unlocking-the-power-of-asyncio-semaphore/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-31T10:10:15+06:00"><meta property="article:modified_time" content="2023-05-31T10:10:15+06:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Unlocking the power of asyncio Semaphore"><meta name=twitter:description content="When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.
asyncio library provides a dedicated synchronization primitive Semaphore created exactly for this purpose. However, let&rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.
We can limit the number of simultaneous connections by using a counter variable that will be incremented whenever we start making a request and decremented when we receive our response. Let&rsquo;s look at the example code:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://olzhasar.com/posts/"},{"@type":"ListItem","position":2,"name":"Unlocking the power of asyncio Semaphore","item":"https://olzhasar.com/posts/unlocking-the-power-of-asyncio-semaphore/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unlocking the power of asyncio Semaphore","name":"Unlocking the power of asyncio Semaphore","description":"When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.\nasyncio library provides a dedicated synchronization primitive Semaphore created exactly for this purpose. However, let\u0026rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.\nWe can limit the number of simultaneous connections by using a counter variable that will be incremented whenever we start making a request and decremented when we receive our response. Let\u0026rsquo;s look at the example code:\n","keywords":["asyncio","python"],"articleBody":"When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.\nasyncio library provides a dedicated synchronization primitive Semaphore created exactly for this purpose. However, let’s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.\nWe can limit the number of simultaneous connections by using a counter variable that will be incremented whenever we start making a request and decremented when we receive our response. Let’s look at the example code:\nimport asyncio import aiohttp URL = \"https://google.com/\" connections = 0 connections_limit = 3 async def make_request(session: aiohttp.ClientSession): global connections while connections \u003e= connections_limit: await asyncio.sleep(0.1) connections += 1 async with session.get(URL) as response: await response.text() connections -= 1 async def main(): async with aiohttp.ClientSession() as session: await asyncio.gather(*(make_request(session) for _ in range(10))) asyncio.run(main()) You may have guessed that this code has a problem - it allows possible race conditions when multiple coroutines try to concurrently mutate our connections variable. This can lead to inaccurate connections counting. We can fix that by introducing a Lock:\nimport asyncio import aiohttp URL = \"https://google.com/\" connections = 0 connections_limit = 3 connections_lock = asyncio.Lock() async def make_request(session: aiohttp.ClientSession): global connections while connections \u003e= connections_limit: await asyncio.sleep(0.1) async with connections_lock: connections += 1 async with session.get(URL) as response: await response.text() async with connections_lock: connections -= 1 async def main(): async with aiohttp.ClientSession() as session: await asyncio.gather(*(make_request(session) for _ in range(10))) asyncio.run(main()) Now the connections_lock ensures that only a single coroutine can mutate the connections variable at any moment in time. Even though this example now works, the code is far from being beautiful. It can however be simplified significantly by using the above mentioned Semaphore primitive:\nimport asyncio import aiohttp URL = \"https://google.com/\" connections = 0 sem = asyncio.Semaphore(3) async def make_request(session: aiohttp.ClientSession): async with sem: async with session.get(URL) as response: await response.text() async def main(): async with aiohttp.ClientSession() as session: await asyncio.gather(*(make_request(session) for _ in range(10))) asyncio.run(main()) This code does pretty much the same job as the example with the Lock. asyncio.Semaphore automatically blocks the execution of the coroutine if the number of currently acquired locks that were not released exceeds the specified capacity.\n","wordCount":"381","inLanguage":"en","datePublished":"2023-05-31T10:10:15+06:00","dateModified":"2023-05-31T10:10:15+06:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://olzhasar.com/posts/unlocking-the-power-of-asyncio-semaphore/"},"publisher":{"@type":"Organization","name":"Olzhas Arystanov","logo":{"@type":"ImageObject","url":"https://olzhasar.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://olzhasar.com/ accesskey=h title="Olzhas Arystanov (Alt + H)">Olzhas Arystanov</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://olzhasar.com/ title=Posts><span>Posts</span></a></li><li><a href=https://olzhasar.com/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://olzhasar.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://olzhasar.com/>Home</a>&nbsp;»&nbsp;<a href=https://olzhasar.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Unlocking the power of asyncio Semaphore</h1><div class=post-meta><span title='2023-05-31 10:10:15 +0600 +0600'>May 31, 2023</span></div></header><div class=post-content><p>When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.</p><p><code>asyncio</code> library provides a dedicated synchronization primitive <a href=https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore><code>Semaphore</code></a> created exactly for this purpose. However, let&rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.</p><p>We can limit the number of simultaneous connections by using a <code>counter</code> variable that will be incremented whenever we start making a request and decremented when we receive our response. Let&rsquo;s look at the example code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> aiohttp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://google.com/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connections <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>connections_limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_request</span>(session: aiohttp<span style=color:#f92672>.</span>ClientSession):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> connections
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> connections <span style=color:#f92672>&gt;=</span> connections_limit:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    connections <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(URL) <span style=color:#66d9ef>as</span> response:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> response<span style=color:#f92672>.</span>text()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    connections <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>(make_request(session) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>You may have guessed that this code has a problem - it allows possible race conditions when multiple <code>coroutines</code> try to concurrently mutate our <code>connections</code> variable. This can lead to inaccurate connections counting. We can fix that by introducing a <a href=https://docs.python.org/3/library/asyncio-sync.html#lock><code>Lock</code></a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> aiohttp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://google.com/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connections <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>connections_limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>connections_lock <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>Lock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_request</span>(session: aiohttp<span style=color:#f92672>.</span>ClientSession):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> connections
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> connections <span style=color:#f92672>&gt;=</span> connections_limit:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> connections_lock:
</span></span><span style=display:flex><span>        connections <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(URL) <span style=color:#66d9ef>as</span> response:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> response<span style=color:#f92672>.</span>text()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> connections_lock:
</span></span><span style=display:flex><span>        connections <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>(make_request(session) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>Now the <code>connections_lock</code> ensures that only a single <code>coroutine</code> can mutate the <code>connections</code> variable at any moment in time. Even though this example now works, the code is far from being beautiful. It can however be simplified significantly by using the above mentioned <a href=https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore><code>Semaphore</code></a> primitive:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> aiohttp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://google.com/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connections <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>sem <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>Semaphore(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_request</span>(session: aiohttp<span style=color:#f92672>.</span>ClientSession):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> sem:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(URL) <span style=color:#66d9ef>as</span> response:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>await</span> response<span style=color:#f92672>.</span>text()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>(make_request(session) <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>This code does pretty much the same job as the example with the Lock. <code>asyncio.Semaphore</code> automatically blocks the execution of the <code>coroutine</code> if the number of currently acquired locks that were not released exceeds the specified capacity.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://olzhasar.com/tags/asyncio/>Asyncio</a></li><li><a href=https://olzhasar.com/tags/python/>Python</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://olzhasar.com/>Olzhas Arystanov</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>