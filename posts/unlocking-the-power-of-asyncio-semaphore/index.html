<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.
asyncio library provides a dedicated synchronization primitive Semaphore created exactly for this purpose. However, let&rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.
We can limit the number of simultaneous connections by using a counter variable that will be incremented whenever we start making a request and decremented when we receive our response."><meta name=color-scheme content="light dark"><meta name=generator content="Hugo 0.110.0"><title>Unlocking the power of asyncio Semaphore | Olzhas Arystanov</title><link rel=canonical href=http://olzhasar.github.io/posts/unlocking-the-power-of-asyncio-semaphore/><link rel=stylesheet href=/css/base.min.e3f991cec7ddedd0d415a66664fd8683ba4cfd357f98e4a127518a15ddb44581.css integrity="sha256-4/mRzsfd7dDUFaZmZP2Gg7pM/TV/mOShJ1GKFd20RYE=" crossorigin=anonymous><script src=https://cdn.counter.dev/script.js data-id=3dd77a42-dfdd-4a54-b59c-cfff02697a3f data-utcoffset=6></script></head><body><nav class=u-background><div class=u-wrapper><ul class=Banner><li class="Banner-item Banner-item--title"><h1 class=Banner-heading><a class="Banner-link u-clickable" href=/>Olzhas Arystanov</a></h1></li><li class=Banner-item><a class="Banner-link u-clickable" href=/about/>About</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/>Posts</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/tags/>Tags</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/projects/>Projects</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=https://github.com/olzhasar/>Github</a></li></ul></div></nav><main><div class=u-wrapper><div class=u-padding><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=/posts/unlocking-the-power-of-asyncio-semaphore/ rel=bookmark>Unlocking the power of asyncio Semaphore</a></h2><time datetime=2023-05-31T10:10:15+06:00>31 May, 2023</time></header><p>When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.</p><p><code>asyncio</code> library provides a dedicated synchronization primitive <a href=https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore><code>Semaphore</code></a> created exactly for this purpose. However, let&rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.</p><p>We can limit the number of simultaneous connections by using a <code>counter</code> variable that will be incremented whenever we start making a request and decremented when we receive our response. Let&rsquo;s look at the example code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> aiohttp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://google.com/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connections <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>connections_limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_request</span>(session: aiohttp<span style=color:#f92672>.</span>ClientSession, i: int):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> connections
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> connections <span style=color:#f92672>&gt;=</span> connections_limit:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    connections <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(URL) <span style=color:#66d9ef>as</span> response:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> response<span style=color:#f92672>.</span>text()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    connections <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>(make_request(session, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())</span></span></code></pre></div><p>You may have guessed that this code has a problem - it allows possible race conditions when multiple coroutines try to concurrently mutate our <code>connections</code> variable. This can lead to inaccurate connections counting. We can fix that by introducing a <a href=https://docs.python.org/3/library/asyncio-sync.html#lock><code>Lock</code></a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> aiohttp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://google.com/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connections <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>connections_limit <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>connections_lock <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>Lock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_request</span>(session: aiohttp<span style=color:#f92672>.</span>ClientSession, i: int):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> connections
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> connections <span style=color:#f92672>&gt;=</span> connections_limit:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>0.1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> connections_lock:
</span></span><span style=display:flex><span>        connections <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(URL) <span style=color:#66d9ef>as</span> response:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> response<span style=color:#f92672>.</span>text()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> connections_lock:
</span></span><span style=display:flex><span>        connections <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>(make_request(session, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())</span></span></code></pre></div><p>Now the <code>connections_lock</code> ensures that only a single coroutine can mutate our <code>connections</code> variable at any moment in time. Even though this example now works, the code is far from being beautiful. It can however be simplified significantly by using the above mentioned <a href=https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore><code>Semaphore</code></a> primitive:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> aiohttp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>URL <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://google.com/&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>connections <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>sem <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>Semaphore(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_request</span>(session: aiohttp<span style=color:#f92672>.</span>ClientSession, i: int):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> sem:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> session<span style=color:#f92672>.</span>get(URL) <span style=color:#66d9ef>as</span> response:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>await</span> response<span style=color:#f92672>.</span>text()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>with</span> aiohttp<span style=color:#f92672>.</span>ClientSession() <span style=color:#66d9ef>as</span> session:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>(make_request(session, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())</span></span></code></pre></div><p>This code does pretty much the same job as the example with the Lock. <code>asyncio.Semaphore</code> automatically blocks the execution of the coroutine if the number of currently acquired locks that were not released exceeds the specified capacity.</p></article></div></div></main><footer class=Footer><div class=u-wrapper><div class=u-padding>© Olzhas Arystanov 2021-2023</div></div></footer></body></html>