<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Optimizing your Django tests | Olzhas Arystanov</title>
<meta name=keywords content="django,pytest,python"><meta name=description content="If you are working on a large Django project, you probably have lots of automated tests running as part of your CI/CD process. As long as tests run fast, everyone is happy. But as your application grows in complexity, your tests start to take more and more time to run and eventually become a real bottleneck. In this post, I will share some ideas that can help you optimize runtime of your test suite. I assume you are using pytest, but recommendations described in this post should be easily applicable to other runners as well."><meta name=author content><link rel=canonical href=https://olzhasar.com/posts/optimizing-your-django-tests/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://olzhasar.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://olzhasar.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://olzhasar.com/favicon-32x32.png><link rel=apple-touch-icon href=https://olzhasar.com/apple-touch-icon.png><link rel=mask-icon href=https://olzhasar.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://olzhasar.com/posts/optimizing-your-django-tests/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.counter.dev/script.js data-id=3dd77a42-dfdd-4a54-b59c-cfff02697a3f data-utcoffset=6></script><meta property="og:title" content="Optimizing your Django tests"><meta property="og:description" content="If you are working on a large Django project, you probably have lots of automated tests running as part of your CI/CD process. As long as tests run fast, everyone is happy. But as your application grows in complexity, your tests start to take more and more time to run and eventually become a real bottleneck. In this post, I will share some ideas that can help you optimize runtime of your test suite. I assume you are using pytest, but recommendations described in this post should be easily applicable to other runners as well."><meta property="og:type" content="article"><meta property="og:url" content="https://olzhasar.com/posts/optimizing-your-django-tests/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-16T00:00:00+00:00"><meta property="article:modified_time" content="2021-09-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Optimizing your Django tests"><meta name=twitter:description content="If you are working on a large Django project, you probably have lots of automated tests running as part of your CI/CD process. As long as tests run fast, everyone is happy. But as your application grows in complexity, your tests start to take more and more time to run and eventually become a real bottleneck. In this post, I will share some ideas that can help you optimize runtime of your test suite. I assume you are using pytest, but recommendations described in this post should be easily applicable to other runners as well."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://olzhasar.com/posts/"},{"@type":"ListItem","position":2,"name":"Optimizing your Django tests","item":"https://olzhasar.com/posts/optimizing-your-django-tests/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Optimizing your Django tests","name":"Optimizing your Django tests","description":"If you are working on a large Django project, you probably have lots of automated tests running as part of your CI/CD process. As long as tests run fast, everyone is happy. But as your application grows in complexity, your tests start to take more and more time to run and eventually become a real bottleneck. In this post, I will share some ideas that can help you optimize runtime of your test suite. I assume you are using pytest, but recommendations described in this post should be easily applicable to other runners as well.\n","keywords":["django","pytest","python"],"articleBody":"If you are working on a large Django project, you probably have lots of automated tests running as part of your CI/CD process. As long as tests run fast, everyone is happy. But as your application grows in complexity, your tests start to take more and more time to run and eventually become a real bottleneck. In this post, I will share some ideas that can help you optimize runtime of your test suite. I assume you are using pytest, but recommendations described in this post should be easily applicable to other runners as well.\nUse a simple password hashing algorithm in your tests Django uses a strong password hashing algorithm (PBFDF2 at the time of writing this post) by default which is a sensible practice to ensure security of your applications. However, such level of security is (usually) not needed in tests. You can use a simple hashing algorithm to significantly reduce hashing operations time. Here is an example configuration block to put in your test settings:\n[ \"django.contrib.auth.hashers.MD5PasswordHasher\", ] This will tell Django to use MD5 algorithm for password hashing operations.\nOptimize migrations Every time your test suite starts to run, Django will create an empty database and then run all migrations to create necessary schema. This can take long time, especially if there is a latency between your test runner and test database.\nCreate test database directly from models One possible optimization is to create a test database directly from Django models without running any migrations. pytest-django has a special flag –no-migrations for that. This approach will reduce db creation time if you have lots of migrations in your project. The downside is that you will lose data migrations as well, which some projects may need to rely on in their tests.\nSquash existing migrations Another solution is to squash your existing migrations. Django provides a management command called squashmigrations. You probably should be squashing your migrations periodically not only to speed tests but also to keep your codebase clean and compact.\nUse a pre-made dump to create your database Sometimes squashing is not an easy option, e.g. when your migrations rely heavily on RunPython and RunSQL commands. In that case there is another solution which I applied to a project with immense amount of migrations. The idea is to create a cron task that will periodically take the recent codebase from your stable branch, create a new database by applying all migrations and upload a resulting dump to a place where it can be downloaded later by your CI runner. In order for this method to work, you need to customize how your test database is being created. pytest-django has django-db-setup fixture which can be customized to alter database creation process. You need to change it to use a pre-made dump instead of creating database from scratch. After creating the database, only newly added migrations are left to be applied which can save a lot of time.\nUse in-memory database if possible If your data layer is simple enough and does not rely on any database vendor-specific fields or indexes, using in-memory database engine in your tests can be the easiest way to speed things up. Django allows using in-memory version of sqlite database during tests which will avoid any disk IO altogether and make working with database in your tests blazing fast.\nHere is the example configuration for using in-memory database in your test settings:\nDATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': 'file::memory:', } } Despite outstanding speed improvements, this approach is less safe than using the same db engine in your tests as in your prod environment. There is a little chance of difference in behavior between databases which can potentially lead to uncovered scenarios. For that reason it should probably be avoided for large projects with critical functionality.\n","wordCount":"636","inLanguage":"en","datePublished":"2021-09-16T00:00:00Z","dateModified":"2021-09-16T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://olzhasar.com/posts/optimizing-your-django-tests/"},"publisher":{"@type":"Organization","name":"Olzhas Arystanov","logo":{"@type":"ImageObject","url":"https://olzhasar.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://olzhasar.com/ accesskey=h title="Olzhas Arystanov (Alt + H)">Olzhas Arystanov</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://olzhasar.com/ title=Posts><span>Posts</span></a></li><li><a href=https://olzhasar.com/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://olzhasar.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://olzhasar.com/>Home</a>&nbsp;»&nbsp;<a href=https://olzhasar.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Optimizing your Django tests</h1><div class=post-meta><span title='2021-09-16 00:00:00 +0000 UTC'>September 16, 2021</span></div></header><div class=post-content><p>If you are working on a large Django project, you probably have lots of automated tests running as part of your CI/CD process. As long as tests run fast, everyone is happy. But as your application grows in complexity, your tests start to take more and more time to run and eventually become a real bottleneck. In this post, I will share some ideas that can help you optimize runtime of your test suite. I assume you are using <strong><code>pytest</code></strong>, but recommendations described in this post should be easily applicable to other runners as well.</p><h2 id=use-a-simple-password-hashing-algorithm-in-your-tests>Use a simple password hashing algorithm in your tests<a hidden class=anchor aria-hidden=true href=#use-a-simple-password-hashing-algorithm-in-your-tests>#</a></h2><p>Django uses a strong password hashing algorithm (<a href=https://en.wikipedia.org/wiki/PBKDF2><code>PBFDF2</code></a> at the time of writing this post) by default which is a sensible practice to ensure security of your applications. However, such level of security is (usually) not needed in tests. You can use a simple hashing algorithm to significantly reduce hashing operations time. Here is an example configuration block to put in your test settings:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py3 data-lang=py3><span style=display:flex><span>[
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;django.contrib.auth.hashers.MD5PasswordHasher&#34;</span>,
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>This will tell <code>Django</code> to use <code>MD5</code> algorithm for password hashing operations.</p><h2 id=optimize-migrations>Optimize migrations<a hidden class=anchor aria-hidden=true href=#optimize-migrations>#</a></h2><p>Every time your test suite starts to run, Django will create an empty database and then run all migrations to create necessary schema. This can take long time, especially if there is a latency between your test runner and test database.</p><h3 id=create-test-database-directly-from-models>Create test database directly from models<a hidden class=anchor aria-hidden=true href=#create-test-database-directly-from-models>#</a></h3><p>One possible optimization is to create a test database directly from Django models without running any migrations. <code>pytest-django</code> has a special flag <a href=https://pytest-django.readthedocs.io/en/latest/database.html#no-migrations-disable-django-migrations>&ndash;no-migrations</a> for that. This approach will reduce db creation time if you have lots of migrations in your project. The downside is that you will lose data migrations as well, which some projects may need to rely on in their tests.</p><h3 id=squash-existing-migrations>Squash existing migrations<a hidden class=anchor aria-hidden=true href=#squash-existing-migrations>#</a></h3><p>Another solution is to squash your existing migrations. Django provides a management command called <a href=https://docs.djangoproject.com/en/dev/topics/migrations/#migration-squashing><code>squashmigrations</code></a>. You probably should be squashing your migrations periodically not only to speed tests but also to keep your codebase clean and compact.</p><h3 id=use-a-pre-made-dump-to-create-your-database>Use a pre-made dump to create your database<a hidden class=anchor aria-hidden=true href=#use-a-pre-made-dump-to-create-your-database>#</a></h3><p>Sometimes squashing is not an easy option, e.g. when your migrations rely heavily on <code>RunPython</code> and <code>RunSQL</code> commands. In that case there is another solution which I applied to a project with immense amount of migrations. The idea is to create a <code>cron</code> task that will periodically take the recent codebase from your stable branch, create a new database by applying all migrations and upload a resulting dump to a place where it can be downloaded later by your CI runner. In order for this method to work, you need to customize how your test database is being created. <code>pytest-django</code> has <a href=https://pytest-django.readthedocs.io/en/latest/database.html#django-db-setup>django-db-setup</a> fixture which can be customized to alter database creation process. You need to change it to use a pre-made dump instead of creating database from scratch. After creating the database, only newly added migrations are left to be applied which can save a lot of time.</p><h2 id=use-in-memory-database-if-possible>Use in-memory database if possible<a hidden class=anchor aria-hidden=true href=#use-in-memory-database-if-possible>#</a></h2><p>If your data layer is simple enough and does not rely on any database vendor-specific fields or indexes, using in-memory database engine in your tests can be the easiest way to speed things up. Django allows using <strong>in-memory</strong> version of <code>sqlite</code> database during tests which will avoid any disk IO altogether and make working with database in your tests blazing fast.</p><p>Here is the example configuration for using in-memory database in your test settings:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py3 data-lang=py3><span style=display:flex><span>DATABASES <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;default&#39;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;ENGINE&#39;</span>: <span style=color:#e6db74>&#39;django.db.backends.sqlite3&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;NAME&#39;</span>: <span style=color:#e6db74>&#39;file::memory:&#39;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Despite outstanding speed improvements, this approach is less safe than using the same db engine in your tests as in your prod environment. There is a little chance of difference in behavior between databases which can potentially lead to uncovered scenarios. For that reason it should probably be avoided for large projects with critical functionality.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://olzhasar.com/tags/django/>Django</a></li><li><a href=https://olzhasar.com/tags/pytest/>Pytest</a></li><li><a href=https://olzhasar.com/tags/python/>Python</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://olzhasar.com/>Olzhas Arystanov</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>