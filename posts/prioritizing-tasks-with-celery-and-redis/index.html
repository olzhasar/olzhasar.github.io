<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Prioritizing Tasks With Celery and Redis | Olzhas Arystanov</title>
<meta name=keywords content><meta name=description content="Task prioritization can be an effective technique to ensure the most critical tasks are processed in time. There are other ways to achieve this, like using dedicated workers, but prioritizing is arguably the simplest, and in many cases, the most cost-effective approach. Celery supports task prioritization natively, but it works differently depending on the broker you use. If you use RabbitMQ, for example, prioritizing will be handled on the broker side, meaning that the broker will decide which message to deliver first. However, RabbitMQ might be an overkill for a lot of projects, and Redis is often preferred due to its simplicity. It turns out, one can still prioritize tasks with Redis, but it works in a slightly different fashion."><meta name=author content><link rel=canonical href=https://olzhasar.com/posts/prioritizing-tasks-with-celery-and-redis/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://olzhasar.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://olzhasar.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://olzhasar.com/favicon-32x32.png><link rel=apple-touch-icon href=https://olzhasar.com/apple-touch-icon.png><link rel=mask-icon href=https://olzhasar.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://olzhasar.com/posts/prioritizing-tasks-with-celery-and-redis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.counter.dev/script.js data-id=3dd77a42-dfdd-4a54-b59c-cfff02697a3f data-utcoffset=6></script><meta property="og:title" content="Prioritizing Tasks With Celery and Redis"><meta property="og:description" content="Task prioritization can be an effective technique to ensure the most critical tasks are processed in time. There are other ways to achieve this, like using dedicated workers, but prioritizing is arguably the simplest, and in many cases, the most cost-effective approach. Celery supports task prioritization natively, but it works differently depending on the broker you use. If you use RabbitMQ, for example, prioritizing will be handled on the broker side, meaning that the broker will decide which message to deliver first. However, RabbitMQ might be an overkill for a lot of projects, and Redis is often preferred due to its simplicity. It turns out, one can still prioritize tasks with Redis, but it works in a slightly different fashion."><meta property="og:type" content="article"><meta property="og:url" content="https://olzhasar.com/posts/prioritizing-tasks-with-celery-and-redis/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-01T21:32:41+05:00"><meta property="article:modified_time" content="2024-09-01T21:32:41+05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Prioritizing Tasks With Celery and Redis"><meta name=twitter:description content="Task prioritization can be an effective technique to ensure the most critical tasks are processed in time. There are other ways to achieve this, like using dedicated workers, but prioritizing is arguably the simplest, and in many cases, the most cost-effective approach. Celery supports task prioritization natively, but it works differently depending on the broker you use. If you use RabbitMQ, for example, prioritizing will be handled on the broker side, meaning that the broker will decide which message to deliver first. However, RabbitMQ might be an overkill for a lot of projects, and Redis is often preferred due to its simplicity. It turns out, one can still prioritize tasks with Redis, but it works in a slightly different fashion."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://olzhasar.com/posts/"},{"@type":"ListItem","position":2,"name":"Prioritizing Tasks With Celery and Redis","item":"https://olzhasar.com/posts/prioritizing-tasks-with-celery-and-redis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Prioritizing Tasks With Celery and Redis","name":"Prioritizing Tasks With Celery and Redis","description":"Task prioritization can be an effective technique to ensure the most critical tasks are processed in time. There are other ways to achieve this, like using dedicated workers, but prioritizing is arguably the simplest, and in many cases, the most cost-effective approach. Celery supports task prioritization natively, but it works differently depending on the broker you use. If you use RabbitMQ, for example, prioritizing will be handled on the broker side, meaning that the broker will decide which message to deliver first. However, RabbitMQ might be an overkill for a lot of projects, and Redis is often preferred due to its simplicity. It turns out, one can still prioritize tasks with Redis, but it works in a slightly different fashion.\n","keywords":[],"articleBody":"Task prioritization can be an effective technique to ensure the most critical tasks are processed in time. There are other ways to achieve this, like using dedicated workers, but prioritizing is arguably the simplest, and in many cases, the most cost-effective approach. Celery supports task prioritization natively, but it works differently depending on the broker you use. If you use RabbitMQ, for example, prioritizing will be handled on the broker side, meaning that the broker will decide which message to deliver first. However, RabbitMQ might be an overkill for a lot of projects, and Redis is often preferred due to its simplicity. It turns out, one can still prioritize tasks with Redis, but it works in a slightly different fashion.\nHow task prioritization works in Celery with Redis as a broker Redis, being essentially a key-value store, doesn’t support task priorities out of the box. However, celery emulates broker-side priorities by using separate queues for different priority levels. When you send a task with a certain priority level, it will be placed in a corresponding queue. The worker will then decide which queue to consume tasks from based on the queue priority. As celery docs state, this will never be as good as broker-side prioritization, but in my experience, it works well enough.\nSetting up task priorities with Celery and Redis Firstly, you need to set the queue_order_strategy in the celery configuration:\napp.conf.broker_transport_options = { 'queue_order_strategy': 'priority', } Or, if you are configuring celery from django settings:\nCELERY_BROKER_TRANSPORT_OPTIONS = { 'queue_order_strategy': 'priority', } celery creates 4 queues by default, while the priority levels are 0-9. I personally find it confusing, so I prefer to explicitly define the queues:\napp.conf.broker_transport_options = { 'priority_steps': list(range(10)), 'sep': ':', 'queue_order_strategy': 'priority', } We now have 10 separate queues for each priority level (0-9).\nIMPORTANT: Lower values correspond to higher priority levels, so tasks with 0 priority value will be processed first.\nLast thing, we need to make sure we don’t prefetch a lot of tasks at once, otherwise, prioritization will not make much sense. Imagine your worker prefetched 10 tasks in advance, and something critical comes up. You will have to wait for existing (probably less important) tasks to get finished before you can proceed with the critical one. There is a worker_prefetch_multiplier setting responsible for this behavior. The value defaults to 4, to spend less time fetching, but if we want robust prioritization, value of 1 will be best:\napp.conf.worker_prefetch_multiplier = 1 That’s it! We now have task prioritization set up with Celery and Redis.\nTask prioritization in practice Priorities can be set when defining a task:\n@app.task(priority=0) def critical_task(): pass @app.task(priority=4) def regular_task(): pass @app.task(priority=9) def not_so_important_task(): pass You can also override the priority when sending a task:\ncritical_task.apply_async(args=['foo'], kwargs={'bar': 1}, priority=5) ","wordCount":"460","inLanguage":"en","datePublished":"2024-09-01T21:32:41+05:00","dateModified":"2024-09-01T21:32:41+05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://olzhasar.com/posts/prioritizing-tasks-with-celery-and-redis/"},"publisher":{"@type":"Organization","name":"Olzhas Arystanov","logo":{"@type":"ImageObject","url":"https://olzhasar.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://olzhasar.com/ accesskey=h title="Olzhas Arystanov (Alt + H)">Olzhas Arystanov</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://olzhasar.com/ title=Posts><span>Posts</span></a></li><li><a href=https://olzhasar.com/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://olzhasar.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://olzhasar.com/>Home</a>&nbsp;»&nbsp;<a href=https://olzhasar.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Prioritizing Tasks With Celery and Redis</h1><div class=post-meta><span title='2024-09-01 21:32:41 +0500 +0500'>September 1, 2024</span></div></header><div class=post-content><p>Task prioritization can be an effective technique to ensure the most critical tasks are processed in time. There are other ways to achieve this, like using dedicated workers, but prioritizing is arguably the simplest, and in many cases, the most cost-effective approach. Celery supports task prioritization natively, but it works differently depending on the broker you use. If you use RabbitMQ, for example, prioritizing will be handled on the broker side, meaning that the broker will decide which message to deliver first. However, RabbitMQ might be an overkill for a lot of projects, and Redis is often preferred due to its simplicity. It turns out, one can still prioritize tasks with Redis, but it works in a slightly different fashion.</p><h2 id=how-task-prioritization-works-in-celery-with-redis-as-a-broker>How task prioritization works in Celery with Redis as a broker<a hidden class=anchor aria-hidden=true href=#how-task-prioritization-works-in-celery-with-redis-as-a-broker>#</a></h2><p>Redis, being essentially a key-value store, doesn&rsquo;t support task priorities out of the box. However, <code>celery</code> emulates broker-side priorities by using separate queues for different priority levels. When you send a task with a certain priority level, it will be placed in a corresponding queue. The worker will then decide which queue to consume tasks from based on the queue priority. As celery docs state, this will never be as good as broker-side prioritization, but in my experience, it works well enough.</p><h2 id=setting-up-task-priorities-with-celery-and-redis>Setting up task priorities with Celery and Redis<a hidden class=anchor aria-hidden=true href=#setting-up-task-priorities-with-celery-and-redis>#</a></h2><p>Firstly, you need to set the <code>queue_order_strategy</code> in the celery configuration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>app<span style=color:#f92672>.</span>conf<span style=color:#f92672>.</span>broker_transport_options <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;queue_order_strategy&#39;</span>: <span style=color:#e6db74>&#39;priority&#39;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Or, if you are configuring <code>celery</code> from <code>django</code> settings:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>CELERY_BROKER_TRANSPORT_OPTIONS <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;queue_order_strategy&#39;</span>: <span style=color:#e6db74>&#39;priority&#39;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>celery</code> creates 4 queues by default, while the priority levels are 0-9. I personally find it confusing, so I prefer to explicitly define the queues:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>app<span style=color:#f92672>.</span>conf<span style=color:#f92672>.</span>broker_transport_options <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;priority_steps&#39;</span>: list(range(<span style=color:#ae81ff>10</span>)),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;sep&#39;</span>: <span style=color:#e6db74>&#39;:&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;queue_order_strategy&#39;</span>: <span style=color:#e6db74>&#39;priority&#39;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We now have 10 separate queues for each priority level (0-9).</p><p><strong>IMPORTANT</strong>: Lower values correspond to higher priority levels, so tasks with 0 priority value will be processed first.</p><p>Last thing, we need to make sure we don&rsquo;t prefetch a lot of tasks at once, otherwise, prioritization will not make much sense. Imagine your worker prefetched 10 tasks in advance, and something critical comes up. You will have to wait for existing (probably less important) tasks to get finished before you can proceed with the critical one. There is a <code>worker_prefetch_multiplier</code> setting responsible for this behavior. The value defaults to 4, to spend less time fetching, but if we want robust prioritization, value of 1 will be best:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>app<span style=color:#f92672>.</span>conf<span style=color:#f92672>.</span>worker_prefetch_multiplier <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>That&rsquo;s it! We now have task prioritization set up with Celery and Redis.</p><h2 id=task-prioritization-in-practice>Task prioritization in practice<a hidden class=anchor aria-hidden=true href=#task-prioritization-in-practice>#</a></h2><p>Priorities can be set when defining a task:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@app.task</span>(priority<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>critical_task</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.task</span>(priority<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>regular_task</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.task</span>(priority<span style=color:#f92672>=</span><span style=color:#ae81ff>9</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>not_so_important_task</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p>You can also override the priority when sending a task:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>critical_task<span style=color:#f92672>.</span>apply_async(args<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;foo&#39;</span>], kwargs<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#39;bar&#39;</span>: <span style=color:#ae81ff>1</span>}, priority<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://olzhasar.com/>Olzhas Arystanov</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>