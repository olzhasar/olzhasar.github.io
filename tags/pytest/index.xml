<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="http://olzhasar.github.io/xml/base.min.xml"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pytest on Olzhas Arystanov</title><link>http://olzhasar.github.io/tags/pytest/</link><description>Recent content in pytest on Olzhas Arystanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Jun 2023 05:37:36 +0600</lastBuildDate><atom:link href="http://olzhasar.github.io/tags/pytest/index.xml" rel="self" type="application/rss+xml"/><item><title>The truth about becoming a self-taught software engineer</title><link>http://olzhasar.github.io/posts/the-truth-about-becoming-a-self-taught-software-engineer/</link><pubDate>Wed, 05 Jul 2023 12:17:58 +0600</pubDate><guid>http://olzhasar.github.io/posts/the-truth-about-becoming-a-self-taught-software-engineer/</guid><description>&lt;p>I graduated from a university with a degree in Finance and immediately started my career in investment banking. After about 7 years of working in the industry, the realization came to me that it wasn&amp;rsquo;t for me. So in my late 20s I decided to change my career path completely and become a software engineer. I did not have much time nor motivation to obtain another college degree, so I decided to take self learning path. And the transitioning process was much harder than I could imagine, it was probably the hardest thing I&amp;rsquo;ve ever done in my life.&lt;/p>
&lt;p>In this blog post, I would like to give people thinking about diving into software engineering a realistic understanding of what should they prepare themselves for.&lt;/p>
&lt;h2 id="software-engineering-is-hard">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/the-truth-about-becoming-a-self-taught-software-engineer/#software-engineering-is-hard">Software engineering is hard&lt;/a>
&lt;/h2>
&lt;p>Contrary to what another youtube ad or a blog post on Medium try to convince you in, becoming a software engineer is extremely hard. You have to learn tons of things to even become a junior developer. I&amp;rsquo;m a back end engineer, so let&amp;rsquo;s take this path as an example.&lt;/p>
&lt;p>Bootcamps and online schools may assure you that all you need to learn is a general purpose programming language like Python or JavaScript and you will be all set. And they promise that you can learn a language in a couple of weeks. First of all, it take much longer to actually learn a language, even the one with a relatively low entry barrier (e.g. Python).&lt;/p>
&lt;p>Secondly and most importantly, learning a language alone is not even a major piece of the puzzle. In order to effectively build modern server side applications, you need to have a solid understanding of algorithms and data structures, software development practices, internet protocols, servers, databases, source control, containerization, and the list goes on. Do not believe anyone who assures you that you can learn everything in 6 months, it takes years to build knowledge in those areas.&lt;/p>
&lt;p>You may think that other career paths can be simpler (e.g. Front end engineering, DevOps, etc.), but I believe that the amount of work that needs to be done is relatively comparable across all those fields, at least in the beginning of your path.&lt;/p>
&lt;p>Even though I truly believe that one can become a software engineer at any age, I also think that it gets increasingly harder as people age. And it&amp;rsquo;s not about neurological changes in your brain, it&amp;rsquo;s more about finding enormous amount of motivation to walk your way through all the difficulties along the way which is just much harder to do at a later stage in life.&lt;/p>
&lt;h2 id="financial-motivation-is-not-enough">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/the-truth-about-becoming-a-self-taught-software-engineer/#financial-motivation-is-not-enough">Financial motivation is not enough&lt;/a>
&lt;/h2>
&lt;p>Nowadays, software engineering is definitely a hyped field. Many people want to get inside mainly because of the perks that come with the field, be it remote working options, high salaries or fancy offices. Even though the compensation can be really good if you land a good job, this motivation alone will not be enough for you to succeed.&lt;/p>
&lt;p>Software engineering is not only about building things and solving problems. It is also about constantly becoming better at those things. Even though it may sound like an obvious statement, in practice it means that you need to spend much more time planning, coding, debugging, refactoring and optimizing code than your actual project requires you to. I am convinced that only with this kind of attitude can you constantly evolve and become better. And considering the fact that there are millions of people around the world doing the same, you simply cannot remain competitive otherwise.&lt;/p>
&lt;h2 id="software-engineering-is-not-for-everyone">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/the-truth-about-becoming-a-self-taught-software-engineer/#software-engineering-is-not-for-everyone">Software engineering is not for everyone&lt;/a>
&lt;/h2>
&lt;p>As rough as it may sound, I believe that software engineering is not for everyone and it never was. It does not mean however that one has to be a genius to become a software engineer. Let me provide an analogy to make this point clear. How many people in the world can become professional athletes? Not so many. Do you have to possess extraordinary physical abilities to become one? Well, sometimes yes, especially if we are talking about breaking world records, but oftentimes it&amp;rsquo;s more about hard work. You have to routinely push yourself to train everyday for years in order to master your sports and become better than others. And even though lots of people can physically do this, a few have a courage and motivation to actually do it. If we think about what differentiates those that succeed from ones that do not, I believe the decisive factor is the passion for the sports. And this one is not easy to cultivate if it&amp;rsquo;s not there.&lt;/p>
&lt;p>I believe the same principle applies to software engineering. Most people are physically able to become software engineers, but not all of them will actually succeed because of the amount of work that needs to be done. If you hate sitting long hours in front of the computer, constantly learning new things, puzzling over hard problems, this may not be for you.&lt;/p>
&lt;h2 id="what-should-you-do-next">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/the-truth-about-becoming-a-self-taught-software-engineer/#what-should-you-do-next">What should you do next&lt;/a>
&lt;/h2>
&lt;p>Even though it may seem that this article is intended to demotivate you, it is actually quite the opposite. The problem is that too many people underestimate how hard the actual career path is. As a result they start with a lot of energy in the beginning that quickly dissolves as they go through first obstacles. Imagine if you were told to run a sprint, but once you reach the finish line, you are now being told that it&amp;rsquo;s a marathon. Will you be able to finish? Will it be harder or easier if you knew about the distance in advance?&lt;/p>
&lt;p>Now, what should you do with all that information? I believe the best way to figure out if this path is for you is to actually try it. Start learning things, give yourself 2-3 months and make an informed decision afterwards. This period is more than enough for you to build a clear picture in your mind and evaluate your feelings throughout the learning process. You will know for sure whether you like it or not. It will be hard in both cases, but you will feel that you still want to continue if it&amp;rsquo;s truly yours. Just don&amp;rsquo;t underestimate the amount of work and prepare for a long battle and you will eventually succeed.&lt;/p></description></item><item><title>Supercharge Your Python TDD Workflow With pytest-watcher</title><link>http://olzhasar.github.io/posts/supercharge-your-python-tdd-workflow-with-pytest-watcher/</link><pubDate>Thu, 08 Jun 2023 05:37:36 +0600</pubDate><guid>http://olzhasar.github.io/posts/supercharge-your-python-tdd-workflow-with-pytest-watcher/</guid><description>&lt;p>If you follow the &lt;a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-driven Development&lt;/a> practice in your Python projects, you need to run your test suite &lt;strong>often&lt;/strong>. Having to run it manually can become tedious. You can configure handy shortcuts in your favorite IDE to make the process easier. But there is even better way using &lt;a href="https://pypi.org/project/pytest-watcher/">&lt;code>pytest-watcher&lt;/code>&lt;/a>.&lt;/p>
&lt;h2 id="what-is-pytest-watcher">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/supercharge-your-python-tdd-workflow-with-pytest-watcher/#what-is-pytest-watcher">What is &lt;code>pytest-watcher&lt;/code>?&lt;/a>
&lt;/h2>
&lt;p>&lt;code>pytest-watcher&lt;/code> is a continuous test runner for Python projects that reruns your tests whenever you change a &lt;code>*.py&lt;/code> file inside your project.&lt;/p>
&lt;p>It uses &lt;code>pytest&lt;/code> as a test runner but you can also configure it to use other test runners (e.g. &lt;code>tox&lt;/code>, &lt;code>unittest&lt;/code>, etc.)&lt;/p>
&lt;h2 id="installing-pytest-watcher">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/supercharge-your-python-tdd-workflow-with-pytest-watcher/#installing-pytest-watcher">Installing pytest-watcher&lt;/a>
&lt;/h2>
&lt;p>You can install the tool like any other Python package with &lt;code>pip&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>pip install pytest-watcher&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="usage">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/supercharge-your-python-tdd-workflow-with-pytest-watcher/#usage">Usage&lt;/a>
&lt;/h2>
&lt;p>Navigate to your project directory and start the &lt;code>pytest-watcher&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ptw .&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>This will tell &lt;code>pytest-watcher&lt;/code> to start listening for filesystem events in the current directory. Now change your code and enjoy your tests restarting automatically.&lt;/p>
&lt;p>Demo:
&lt;img src="http://olzhasar.github.io/pytest-watcher-demo.gif" alt="Demo">&lt;/p>
&lt;h2 id="additional-usage-info">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/supercharge-your-python-tdd-workflow-with-pytest-watcher/#additional-usage-info">Additional usage info&lt;/a>
&lt;/h2>
&lt;p>Visit &lt;a href="https://github.com/olzhasar/pytest-watcher">Github repository&lt;/a> for additional info about using and configuring &lt;code>pytest-watcher&lt;/code>&lt;/p></description></item><item><title>Unlocking the power of asyncio Semaphore</title><link>http://olzhasar.github.io/posts/unlocking-the-power-of-asyncio-semaphore/</link><pubDate>Wed, 31 May 2023 10:10:15 +0600</pubDate><guid>http://olzhasar.github.io/posts/unlocking-the-power-of-asyncio-semaphore/</guid><description>&lt;p>When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.&lt;/p>
&lt;p>&lt;code>asyncio&lt;/code> library provides a dedicated synchronization primitive &lt;a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore">&lt;code>Semaphore&lt;/code>&lt;/a> created exactly for this purpose. However, let&amp;rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.&lt;/p>
&lt;p>We can limit the number of simultaneous connections by using a &lt;code>counter&lt;/code> variable that will be incremented whenever we start making a request and decremented when we receive our response. Let&amp;rsquo;s look at the example code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> asyncio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> aiohttp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>URL &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://google.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connections &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connections_limit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">make_request&lt;/span>(session: aiohttp&lt;span style="color:#f92672">.&lt;/span>ClientSession):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> connections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> connections &lt;span style="color:#f92672">&amp;gt;=&lt;/span> connections_limit:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> asyncio&lt;span style="color:#f92672">.&lt;/span>sleep(&lt;span style="color:#ae81ff">0.1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connections &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(URL) &lt;span style="color:#66d9ef">as&lt;/span> response:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>text()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connections &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> aiohttp&lt;span style="color:#f92672">.&lt;/span>ClientSession() &lt;span style="color:#66d9ef">as&lt;/span> session:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> asyncio&lt;span style="color:#f92672">.&lt;/span>gather(&lt;span style="color:#f92672">*&lt;/span>(make_request(session) &lt;span style="color:#66d9ef">for&lt;/span> _ &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>asyncio&lt;span style="color:#f92672">.&lt;/span>run(main())&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>You may have guessed that this code has a problem - it allows possible race conditions when multiple &lt;code>coroutines&lt;/code> try to concurrently mutate our &lt;code>connections&lt;/code> variable. This can lead to inaccurate connections counting. We can fix that by introducing a &lt;a href="https://docs.python.org/3/library/asyncio-sync.html#lock">&lt;code>Lock&lt;/code>&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> asyncio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> aiohttp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>URL &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://google.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connections &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connections_limit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connections_lock &lt;span style="color:#f92672">=&lt;/span> asyncio&lt;span style="color:#f92672">.&lt;/span>Lock()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">make_request&lt;/span>(session: aiohttp&lt;span style="color:#f92672">.&lt;/span>ClientSession):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> connections
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> connections &lt;span style="color:#f92672">&amp;gt;=&lt;/span> connections_limit:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> asyncio&lt;span style="color:#f92672">.&lt;/span>sleep(&lt;span style="color:#ae81ff">0.1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> connections_lock:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connections &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(URL) &lt;span style="color:#66d9ef">as&lt;/span> response:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>text()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> connections_lock:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connections &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> aiohttp&lt;span style="color:#f92672">.&lt;/span>ClientSession() &lt;span style="color:#66d9ef">as&lt;/span> session:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> asyncio&lt;span style="color:#f92672">.&lt;/span>gather(&lt;span style="color:#f92672">*&lt;/span>(make_request(session) &lt;span style="color:#66d9ef">for&lt;/span> _ &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>asyncio&lt;span style="color:#f92672">.&lt;/span>run(main())&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Now the &lt;code>connections_lock&lt;/code> ensures that only a single &lt;code>coroutine&lt;/code> can mutate the &lt;code>connections&lt;/code> variable at any moment in time. Even though this example now works, the code is far from being beautiful. It can however be simplified significantly by using the above mentioned &lt;a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore">&lt;code>Semaphore&lt;/code>&lt;/a> primitive:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> asyncio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> aiohttp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>URL &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://google.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connections &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sem &lt;span style="color:#f92672">=&lt;/span> asyncio&lt;span style="color:#f92672">.&lt;/span>Semaphore(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">make_request&lt;/span>(session: aiohttp&lt;span style="color:#f92672">.&lt;/span>ClientSession):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> sem:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>get(URL) &lt;span style="color:#66d9ef">as&lt;/span> response:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>text()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> aiohttp&lt;span style="color:#f92672">.&lt;/span>ClientSession() &lt;span style="color:#66d9ef">as&lt;/span> session:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> asyncio&lt;span style="color:#f92672">.&lt;/span>gather(&lt;span style="color:#f92672">*&lt;/span>(make_request(session) &lt;span style="color:#66d9ef">for&lt;/span> _ &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">10&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>asyncio&lt;span style="color:#f92672">.&lt;/span>run(main())&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>This code does pretty much the same job as the example with the Lock. &lt;code>asyncio.Semaphore&lt;/code> automatically blocks the execution of the &lt;code>coroutine&lt;/code> if the number of currently acquired locks that were not released exceeds the specified capacity.&lt;/p></description></item><item><title>Advent of Code vs LeetCode</title><link>http://olzhasar.github.io/posts/advent-of-code-vs-leetcode/</link><pubDate>Sat, 20 May 2023 00:00:00 +0000</pubDate><guid>http://olzhasar.github.io/posts/advent-of-code-vs-leetcode/</guid><description>&lt;p>I recently discovered the &lt;a href="https://adventofcode.com/">Advent of Code&lt;/a> project for myself and I absolutely loved it. At first glance, it seemed similar to solving &lt;code>Leetcode&lt;/code> problems. However, after trying it for a few days now I realized that I like the experience much more. In this short blog post I&amp;rsquo;ll try to break down main advantages that I see over &lt;code>Leetcode&lt;/code>:&lt;/p>
&lt;h3 id="no-online-editor">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/advent-of-code-vs-leetcode/#no-online-editor">No online editor&lt;/a>
&lt;/h3>
&lt;p>You don&amp;rsquo;t have to use the poor built-in online editor. I can freely use my favorite &lt;code>Neovim&lt;/code> for this&lt;/p>
&lt;h3 id="freedom-in-choosing-programming-language">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/advent-of-code-vs-leetcode/#freedom-in-choosing-programming-language">Freedom in choosing programming language&lt;/a>
&lt;/h3>
&lt;p>You are not limited at all, you can even use &lt;a href="https://esolangs.org/wiki/Brainfuck">BrainFuck&lt;/a> if you want to. I chose C because I wanted to refresh my knowledge of it and I like to struggle sometimes.&lt;/p>
&lt;h3 id="implement-everything-from-scratch">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/advent-of-code-vs-leetcode/#implement-everything-from-scratch">Implement everything from scratch&lt;/a>
&lt;/h3>
&lt;p>&lt;code>Leetcode&lt;/code> does all the parsing for you and passes the prepared input to your Solution class. Here, all you get is a text input, and you have to implement the parsing logic yourself. This may seem like a disadvantage, but if you use AOC to dive into a new language, this alone can teach you a lot.&lt;/p>
&lt;h3 id="feels-like-a-real-project">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/advent-of-code-vs-leetcode/#feels-like-a-real-project">Feels like a real project&lt;/a>
&lt;/h3>
&lt;p>I always hate the short-term nature of solving &lt;code>Leetcode&lt;/code> problems. It makes me feel like I&amp;rsquo;m wasting time and instead of building something. Here, in contrast, I feel like I&amp;rsquo;m working on a set of side projects. As a result, I care about the code quality much more.&lt;/p>
&lt;h3 id="conclusion">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/advent-of-code-vs-leetcode/#conclusion">Conclusion&lt;/a>
&lt;/h3>
&lt;p>If you haven&amp;rsquo;t yet tried the Advent of Code, I suggest you give it a shot. It&amp;rsquo;s a great way to sharpen your problem solving skills and/or learn new programming language.&lt;/p></description></item><item><title>A better way to prepare for your coding interviews</title><link>http://olzhasar.github.io/posts/a-better-way-to-prepare-for-your-coding-interviews/</link><pubDate>Fri, 19 May 2023 00:00:00 +0000</pubDate><guid>http://olzhasar.github.io/posts/a-better-way-to-prepare-for-your-coding-interviews/</guid><description>&lt;p>I recently started applying to Big Tech companies, and as a result, I ended up solving a lot of LeetCode problems (284 problems at the time of writing this blog post). During the preparation process, it became clear to me why so many developers argue about the broken state of the tech interviewing process. Solving LeetCode problems takes a significant amount of time and energy that could otherwise be spent on building projects. However, I believe that the main issue lies not with the tech interviews themselves, but rather with the preparation process.&lt;/p>
&lt;p>You have probably already chosen a list of LeetCode problems that you need to solve. If you haven&amp;rsquo;t, fortunately, there are good lists available online, such as the &lt;a href="https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions">Blind 75&lt;/a> or &lt;a href="https://neetcode.io/practice">Neetcode 150&lt;/a>. Each list usually covers multiple topics, including arrays, string manipulation, hashmaps, backtracking, dynamic programming, graph algorithms, etc. So, you start solving these problems one by one. If you have a good understanding of each of these topics, solving LeetCode problems becomes almost a mechanical process of sharpening your skills, becoming faster, and getting more accustomed to the coding interview process in general. However, if you lack a solid understanding of any of these areas, that&amp;rsquo;s where the problem arises.&lt;/p>
&lt;p>Let&amp;rsquo;s say you struggle with backtracking algorithms. You have never implemented one before, and you are not sure how they work in general. In that case, there are multiple strategies you can follow:&lt;/p>
&lt;ul>
&lt;li>Spend hours trying to solve the problem by yourself.&lt;/li>
&lt;li>Look up the solution on LeetCode.&lt;/li>
&lt;li>Find a step-by-step guide on solving the problem (e.g., the &lt;a href="https://www.youtube.com/c/neetcode">Neetcode YouTube channel&lt;/a>).&lt;/li>
&lt;/ul>
&lt;p>The first approach is not ideal, especially if you have an ego like myself (I&amp;rsquo;m working on it). You can spend a lot of hours trying hard, but if you are not familiar with the concepts, those hours will likely be wasted. The second and third approaches are much better. You read or watch the solution, understanding the thought process behind it, and then try to replicate it yourself. However, the problem with this approach is that it&amp;rsquo;s still just a single problem out of the 75 or 150 (or however many problems you plan to solve), and you treat it as such. In my experience, this approach does not allow you to fully understand the concept and build a long-term memory of it.&lt;/p>
&lt;p>So, what can we do better to fully grasp the concept? I am a strong advocate of the &amp;ldquo;learning-by-doing&amp;rdquo; technique, and I suggest utilizing it here. The idea is to build a small or medium-sized project in your programming language of choice where a certain concept is applied. For example, if we are talking about backtracking algorithms, you can build a fully functional Sudoku game.&lt;/p>
&lt;p>Why is this approach better?&lt;/p>
&lt;ul>
&lt;li>You can see how the concept you are exploring can be applied to solve a real problem.&lt;/li>
&lt;li>Spending a significant amount of time on a single LeetCode problem can be really tedious. In contrast, building a project should give you much more motivation to stay focused. And it&amp;rsquo;s completely okay to spend multiple days or weeks working on it.&lt;/li>
&lt;li>You are much more likely to return to your project later to polish things than returning to your solved LeetCode problems.&lt;/li>
&lt;li>It should be enough to build a single project for each topic to gain an understanding. After that, you can return to solving LeetCode problems in that topic, and it should be much easier and more fun now.&lt;/li>
&lt;/ul></description></item><item><title>Optimizing your Django tests</title><link>http://olzhasar.github.io/posts/optimizing-your-django-tests/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>http://olzhasar.github.io/posts/optimizing-your-django-tests/</guid><description>&lt;p>If you are working on a large Django project, you probably have lots of automated tests running as part of your CI/CD process. As long as tests run fast, everyone is happy. But as your application grows in complexity, your tests start to take more and more time to run and eventually become a real bottleneck. In this post, I will share some ideas that can help you optimize runtime of your test suite. I assume you are using &lt;strong>&lt;code>pytest&lt;/code>&lt;/strong>, but recommendations described in this post should be easily applicable to other runners as well.&lt;/p>
&lt;h2 id="use-a-simple-password-hashing-algorithm-in-your-tests">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/optimizing-your-django-tests/#use-a-simple-password-hashing-algorithm-in-your-tests">Use a simple password hashing algorithm in your tests&lt;/a>
&lt;/h2>
&lt;p>Django uses a strong password hashing algorithm (&lt;a href="https://en.wikipedia.org/wiki/PBKDF2">&lt;code>PBFDF2&lt;/code>&lt;/a> at the time of writing this post) by default which is a sensible practice to ensure security of your applications. However, such level of security is (usually) not needed in tests. You can use a simple hashing algorithm to significantly reduce hashing operations time. Here is an example configuration block to put in your test settings:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-py3" data-lang="py3">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;django.contrib.auth.hashers.MD5PasswordHasher&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>This will tell &lt;code>Django&lt;/code> to use &lt;code>MD5&lt;/code> algorithm for password hashing operations.&lt;/p>
&lt;h2 id="optimize-migrations">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/optimizing-your-django-tests/#optimize-migrations">Optimize migrations&lt;/a>
&lt;/h2>
&lt;p>Every time your test suite starts to run, Django will create an empty database and then run all migrations to create necessary schema. This can take long time, especially if there is a latency between your test runner and test database.&lt;/p>
&lt;h3 id="create-test-database-directly-from-models">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/optimizing-your-django-tests/#create-test-database-directly-from-models">Create test database directly from models&lt;/a>
&lt;/h3>
&lt;p>One possible optimization is to create a test database directly from Django models without running any migrations. &lt;code>pytest-django&lt;/code> has a special flag &lt;a href="https://pytest-django.readthedocs.io/en/latest/database.html#no-migrations-disable-django-migrations">&amp;ndash;no-migrations&lt;/a> for that. This approach will reduce db creation time if you have lots of migrations in your project. The downside is that you will lose data migrations as well, which some projects may need to rely on in their tests.&lt;/p>
&lt;h3 id="squash-existing-migrations">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/optimizing-your-django-tests/#squash-existing-migrations">Squash existing migrations&lt;/a>
&lt;/h3>
&lt;p>Another solution is to squash your existing migrations. Django provides a management command called &lt;a href="https://docs.djangoproject.com/en/dev/topics/migrations/#migration-squashing">&lt;code>squashmigrations&lt;/code>&lt;/a>. You probably should be squashing your migrations periodically not only to speed tests but also to keep your codebase clean and compact.&lt;/p>
&lt;h3 id="use-a-pre-made-dump-to-create-your-database">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/optimizing-your-django-tests/#use-a-pre-made-dump-to-create-your-database">Use a pre-made dump to create your database&lt;/a>
&lt;/h3>
&lt;p>Sometimes squashing is not an easy option, e.g. when your migrations rely heavily on &lt;code>RunPython&lt;/code> and &lt;code>RunSQL&lt;/code> commands. In that case there is another solution which I applied to a project with immense amount of migrations. The idea is to create a &lt;code>cron&lt;/code> task that will periodically take the recent codebase from your stable branch, create a new database by applying all migrations and upload a resulting dump to a place where it can be downloaded later by your CI runner. In order for this method to work, you need to customize how your test database is being created. &lt;code>pytest-django&lt;/code> has &lt;a href="https://pytest-django.readthedocs.io/en/latest/database.html#django-db-setup">django-db-setup&lt;/a> fixture which can be customized to alter database creation process. You need to change it to use a pre-made dump instead of creating database from scratch. After creating the database, only newly added migrations are left to be applied which can save a lot of time.&lt;/p>
&lt;h2 id="use-in-memory-database-if-possible">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/optimizing-your-django-tests/#use-in-memory-database-if-possible">Use in-memory database if possible&lt;/a>
&lt;/h2>
&lt;p>If your data layer is simple enough and does not rely on any database vendor-specific fields or indexes, using in-memory database engine in your tests can be the easiest way to speed things up. Django allows using &lt;strong>in-memory&lt;/strong> version of &lt;code>sqlite&lt;/code> database during tests which will avoid any disk IO altogether and make working with database in your tests blazing fast.&lt;/p>
&lt;p>Here is the example configuration for using in-memory database in your test settings:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-py3" data-lang="py3">&lt;span style="display:flex;">&lt;span>DATABASES &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;default&amp;#39;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;ENGINE&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;django.db.backends.sqlite3&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;NAME&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;file::memory:&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Despite outstanding speed improvements, this approach is less safe than using the same db engine in your tests as in your prod environment. There is a little chance of difference in behavior between databases which can potentially lead to uncovered scenarios. For that reason it should probably be avoided for large projects with critical functionality.&lt;/p></description></item><item><title>Why Flask will teach you more about software engineering than Django</title><link>http://olzhasar.github.io/posts/why-flask-will-teach-you-more-than-django/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>http://olzhasar.github.io/posts/why-flask-will-teach-you-more-than-django/</guid><description>&lt;h2 id="intro">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/why-flask-will-teach-you-more-than-django/#intro">Intro&lt;/a>
&lt;/h2>
&lt;p>I started my journey in back-end development with Django. That was the first framework that I’ve learned right after familiarizing myself with a bit of Python programming language. Pretty soon I was able to write simple web applications with it. I was so fascinated by the fact that I can build a full-featured website in a couple of days or sometimes hours depending on project complexity. I remember trying Flask for a couple of pet projects. Sometimes I managed to build something simple with it but as soon as complexity of the application started to grow, I would give up sooner or later. Django was so much easier to work with for me as a beginning software engineer. When I was stuck with something in Django, almost every time there would be a detailed answer on &lt;code>stackoverflow&lt;/code>. It was much trickier to find solutions for issues that I faced using Flask. As a result, I played with Flask here and there but never built anything serious with it.&lt;/p>
&lt;h2 id="second-try">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/why-flask-will-teach-you-more-than-django/#second-try">Second try&lt;/a>
&lt;/h2>
&lt;p>After several years of working with Django both at my job and for personal projects, I finally decided to give Flask another try and dive deep into it. The main motivation for me this time was my desire to learn &lt;code>SQLAlchemy&lt;/code> ORM. I was already a middle engineer at that point, knowing something about servers, databases and software design. I started a toy project and surprisingly managed to finish it in a couple of days. Moreover, I totally fell in love with the process of building it. Flask gave me complete freedom over the application design and I utilized that opportunity to create an app that would perfectly suit my every need. I used Flask for almost every personal project since then and I learned a lot while doing them. I thought about my experience with Django and I finally came to a conclusion that choosing Flask at the beginning of my career would be a much more beneficial decision in the long run.&lt;/p>
&lt;p>Let&amp;rsquo;s walk over some points where I think Flask compared to Django can be more enlightening especially to entry-level engineers.&lt;/p>
&lt;h2 id="implementing-things-from-scratch">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/why-flask-will-teach-you-more-than-django/#implementing-things-from-scratch">Implementing things from scratch&lt;/a>
&lt;/h2>
&lt;p>Django comes batteries-included. It has features for almost any use case that an average web project will ever come up with. You can build a working authentication system in Django in no time and knowing nothing about things that are going on under the hood. Django will take care of hashing passwords, storing them in database, verifying them later when a user tries to sign in, managing user sessions, and a lot more.&lt;/p>
&lt;p>Flask in comparison is extremely lightweight out of the box. It does not give you much. You are on your own. You can utilize some third-party library to solve some common tasks, or you can build things from scratch. If you choose the latter option, this is where the actual learning lies. You will spend much more time thinking about what your code is actually doing by starting from zero.&lt;/p>
&lt;h2 id="design-philosophy">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/why-flask-will-teach-you-more-than-django/#design-philosophy">Design philosophy&lt;/a>
&lt;/h2>
&lt;p>Django is an absolutely beautiful piece of software. There are so many brilliant design decisions in Django&amp;rsquo;s codebase that made working with the framework a piece of cake. But there is a downside to that beauty when it comes to learning things because almost all design decisions are already made for you. Django expects almost everything to be done Django-way. You obviously can ditch all the built-in abstractions and write your own from scratch, but this will likely make your project significantly deviate from Django&amp;rsquo;s philosophy. With a complex long-term project, you can come to a point when there are no reasons left to use Django at all.&lt;/p>
&lt;p>Flask, contrastingly, does not force you to do things a certain way. Once again, you have a complete freedom, and you can do pretty much anything you want. That also means that you will probably make bad decisions in the beginning of your journey, but that&amp;rsquo;s where you will learn a lot. If you ever played chess, you probably started as a pretty bad player. But the more bad moves you make and games you lose, the more you analyze your mistakes and correct your strategy, which results in your progress. I believe the same principle applies to software engineering. Nobody learned to produce perfect computer programs right from the start. You absolutely need to make a lot of mistakes and analyze outcomes to truly master your software design skills. And Flask is the perfect tool to make such mistakes and progress as a software engineer.&lt;/p>
&lt;h2 id="sqlalchemy-vs-django-orm">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/why-flask-will-teach-you-more-than-django/#sqlalchemy-vs-django-orm">&lt;code>SQLAlchemy&lt;/code> vs Django ORM&lt;/a>
&lt;/h2>
&lt;p>Even though Flask is not coupled with any ORM solution out of the box, developers typically choose &lt;a href="https://www.sqlalchemy.org/">&lt;code>SQLAlchemy&lt;/code>&lt;/a> to work with relational databases in their Flask applications. Django comes with its own Object-relational mapping tool which is oftentimes called Django ORM. These two ORM solutions follow quite different data access patterns: &lt;code>SQLAlchemy&lt;/code> uses &lt;a href="https://en.wikipedia.org/wiki/Data_mapper_pattern">Data mapper pattern&lt;/a> and Django ORM uses &lt;a href="https://en.wikipedia.org/wiki/Active_record_pattern">Active Record Pattern&lt;/a>. What it means is that Django maps every python object to a particular row in a database whereas in &lt;code>SQLAlchemy&lt;/code> database operations and python objects are separated. Consider the following example of querying and deleting a row in a database:&lt;/p>
&lt;p>Django:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-py3" data-lang="py3">&lt;span style="display:flex;">&lt;span>user &lt;span style="color:#f92672">=&lt;/span> User&lt;span style="color:#f92672">.&lt;/span>objects&lt;span style="color:#f92672">.&lt;/span>get(id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>user&lt;span style="color:#f92672">.&lt;/span>delete()&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>&lt;code>SQLAlchemy&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-py3" data-lang="py3">&lt;span style="display:flex;">&lt;span>user &lt;span style="color:#f92672">=&lt;/span> session&lt;span style="color:#f92672">.&lt;/span>query(User)&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>session&lt;span style="color:#f92672">.&lt;/span>delete(user)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>session&lt;span style="color:#f92672">.&lt;/span>commit()&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Django allows you to call obj.delete() method directly on the model instance because that instance is mapped to a specific row in the database. &lt;code>SQLAlchemy&lt;/code> expects you to use session for making final queries. The latter approach can actually be safer in many situations because you always instruct the database explicitly whether to perform a particular query or not. To illustrate this point, consider the following example in Django:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-py3" data-lang="py3">&lt;span style="display:flex;">&lt;span>users &lt;span style="color:#f92672">=&lt;/span> user&lt;span style="color:#f92672">.&lt;/span>objects&lt;span style="color:#f92672">.&lt;/span>all()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> user &lt;span style="color:#f92672">in&lt;/span> users:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user&lt;span style="color:#f92672">.&lt;/span>name&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>In Django ORM, queries are lazy by default which means their execution is postponed to the last moment when you will actually do something with the data. In this example, the query will be performed only on the second line of code when the iteration starts. Now let&amp;rsquo;s say you have the following code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-py3" data-lang="py3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">some_func&lt;/span>(users):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> user &lt;span style="color:#f92672">in&lt;/span> users:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(user&lt;span style="color:#f92672">.&lt;/span>name)&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>We cannot say for sure when the query will actually be performed because we don&amp;rsquo;t know was this QuerySet of users evaluated earlier or not. This can lead to undesired side effects especially during development of large software projects.&lt;/p>
&lt;p>I&amp;rsquo;ve worked with both object-relational mappers in a bunch of projects and my personal opinion is that &lt;code>SQLAlchemy&lt;/code> is safer and also makes you think more in terms of actual SQL queries that the database will produce compared to Django. Forming that mindset in my opinion is extremely beneficial for any entry-level backend engineer.&lt;/p>
&lt;h2 id="summary">
&lt;a class="Heading-link u-clickable" href="http://olzhasar.github.io/posts/why-flask-will-teach-you-more-than-django/#summary">Summary&lt;/a>
&lt;/h2>
&lt;p>In conclusion, Django is undoubtedly a great web framework that will make your life easier especially if you have tight deadlines and want to iterate as quickly as possible. But it comes with a lot of magic hidden inside that prevents developers from understanding the whole picture. If you are not yet a highly experienced engineer and lack some knowledge, I would strongly recommend you to try Flask at least for your side projects. It will probably take more of your working time if you are just starting out with Flask, but that will be an important investment in your backend development skills. On the other hand, if you are an experienced engineer but want to drop the boundaries and implement your brilliant design decisions in a complete freedom, you will also profit a lot by choosing Flask as your framework.&lt;/p></description></item></channel></rss>