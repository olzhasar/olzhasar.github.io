<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Asyncio on Olzhas Arystanov</title><link>https://olzhasar.com/tags/asyncio/</link><description>Recent content in Asyncio on Olzhas Arystanov</description><generator>Hugo -- 0.135.0</generator><language>en-us</language><lastBuildDate>Wed, 31 May 2023 10:10:15 +0600</lastBuildDate><atom:link href="https://olzhasar.com/tags/asyncio/index.xml" rel="self" type="application/rss+xml"/><item><title>Unlocking the power of asyncio Semaphore</title><link>https://olzhasar.com/posts/unlocking-the-power-of-asyncio-semaphore/</link><pubDate>Wed, 31 May 2023 10:10:15 +0600</pubDate><guid>https://olzhasar.com/posts/unlocking-the-power-of-asyncio-semaphore/</guid><description>&lt;p>When building asynchronous applications, oftentimes you need to limit the number of simultaneous connections to a shared resource. It can be your internal server, or an API that has usage limits.&lt;/p>
&lt;p>&lt;code>asyncio&lt;/code> library provides a dedicated synchronization primitive &lt;a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore">&lt;code>Semaphore&lt;/code>&lt;/a> created exactly for this purpose. However, let&amp;rsquo;s first try to solve this problem without using it, in order to fully appreciate the value of this mechanism.&lt;/p>
&lt;p>We can limit the number of simultaneous connections by using a &lt;code>counter&lt;/code> variable that will be incremented whenever we start making a request and decremented when we receive our response. Let&amp;rsquo;s look at the example code:&lt;/p></description></item></channel></rss>